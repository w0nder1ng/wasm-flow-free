<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta
            http-equiv="Content-Security-Policy"
            content="upgrade-insecure-requests"
        />
        <title>Flow Free</title>
        <link rel="stylesheet" href="/static/styles.css" />
        <link
            rel="manifest"
            type="application/json"
            href="/manifest.webmanifest"
        />
    </head>

    <body>
        <nav>
            <ul>
                <li><a href="index.html">Play</a></li>
                <li><a href="editor.html">Editor</a></li>
            </ul>
        </nav>
        <h1 id="win"></h1>
        <canvas id="draw"></canvas>
        <br />
        <div>
            <button id="copy-btn">Copy puzzle URL to clipboard</button>
            <label for="grid-size">Enter size of grid:</label>
            <input type="number" id="grid-size" />
            <br />
            <button id="new-btn">New puzzle</button>
        </div>
        <noscript
            >This page contains webassembly and javascript content, please
            enable javascript in your browser.</noscript
        >
        <script type="module">
            import init, { Canvas } from "./pkg/wasm_flow_free.js";

            function bytesToBase64(bytes) {
                const binString = Array.from(bytes, (byte) =>
                    String.fromCodePoint(byte),
                ).join("");
                return btoa(binString);
            }
            function base64ToBytes(base64) {
                const binString = atob(base64);
                return Uint8Array.from(binString, (m) => m.codePointAt(0));
            }

            const draw = document.getElementById("draw");
            const ctx = draw.getContext("2d");

            const copybtn = document.getElementById("copy-btn");
            const gridsize = document.getElementById("grid-size");
            const newbtn = document.getElementById("new-btn");
            let wasm = await init();
            let memory = wasm.memory;
            let grid_size = 5;
            const use_filled = false;
            let canvas = use_filled
                ? Canvas.gen_filled_board(grid_size, grid_size)
                : Canvas.gen_new_board(grid_size, grid_size);
            if (window.location.search) {
                let params = new URLSearchParams(window.location.search);
                if (!params.has("size") || !params.has("board")) {
                    console.log("Invalid URL");
                } else {
                    let size = parseInt(params.get("size"));
                    const board = base64ToBytes(params.get("board"));
                    grid_size = size;
                    canvas.resize(size, size);
                    canvas.from_bytes(board);
                    window.history.replaceState(
                        {},
                        document.title,
                        window.location.pathname,
                    );
                }
            }
            gridsize.setAttribute("placeholder", grid_size);

            let buffer = new Uint8ClampedArray(
                memory.buffer,
                canvas.get_pix_buf(),
                canvas.canvas_width() * canvas.canvas_height() * 4,
            );
            let image = new ImageData(
                buffer,
                canvas.canvas_width(),
                canvas.canvas_height(),
            );

            draw.width = canvas.canvas_width();
            draw.height = canvas.canvas_height();
            canvas.render();

            let currently_focused = null;
            let is_mouse_down = false;
            function attemptConnection(delta) {
                // if adding a connection fails, attempt to remove a connection; update position if either succeeds
                if (!currently_focused) {
                    return;
                }
                const result =
                    canvas.add_connection(currently_focused, delta) ||
                    canvas.remove_connection(currently_focused, delta);
                if (result) {
                    if (delta == 0) {
                        currently_focused[0] -= 1;
                    } else if (delta == 1) {
                        currently_focused[0] += 1;
                    } else if (delta == 2) {
                        currently_focused[1] -= 1;
                    } else if (delta == 3) {
                        currently_focused[1] += 1;
                    }
                }
            }
            function mdHandler(e) {
                e.preventDefault();
                let rect = draw.getBoundingClientRect();
                let x = (e.touches ? e.touches[0] : e).clientX - rect.left;
                let y = (e.touches ? e.touches[0] : e).clientY - rect.top;
                canvas.handle_md([x, y]);
            }
            function muHandler(e) {
                canvas.handle_mu();
            }
            function mmHandler(e) {
                let clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let clientY = e.touches ? e.touches[0].clientY : e.clientY;
                canvas.handle_mm([
                    clientX - draw.getBoundingClientRect().left,
                    clientY - draw.getBoundingClientRect().top,
                ]);
                e.preventDefault();
            }

            draw.addEventListener("mousedown", mdHandler);
            draw.addEventListener("mouseup", muHandler);
            draw.addEventListener("mousemove", mmHandler);

            draw.addEventListener("touchstart", mdHandler);

            draw.addEventListener("touchend", muHandler);

            draw.addEventListener("touchmove", mmHandler);

            window.addEventListener("keydown", function (e) {
                let key = e.key;
                if ("wasd".indexOf(key) > -1) {
                    canvas.handle_keypress(key);
                    e.preventDefault();
                }
            });
            copybtn.addEventListener("click", async function () {
                let params = new URLSearchParams();
                let board = canvas.to_bytes();
                let b64 = bytesToBase64(board);
                params.set("board", b64);
                params.set("size", grid_size);
                await navigator.clipboard.writeText(
                    window.location.href.split("?")[0] +
                        "?" +
                        params.toString(),
                );
            });

            gridsize.addEventListener("change", function () {
                grid_size = parseInt(gridsize.value);
                canvas.resize(grid_size, grid_size);
                canvas.render();
                draw.width = canvas.canvas_width();
                draw.height = canvas.canvas_height();

                buffer = new Uint8ClampedArray(
                    memory.buffer,
                    canvas.get_pix_buf(),
                    canvas.canvas_width() * canvas.canvas_height() * 4,
                );
                image = new ImageData(
                    buffer,
                    canvas.canvas_width(),
                    canvas.canvas_height(),
                );

                canvas.render();
            });

            newbtn.addEventListener("click", function () {
                // console.log("new board requested");
                canvas.resize(grid_size, grid_size);
                // console.log("resize completed");
                canvas = use_filled
                    ? Canvas.gen_filled_board(grid_size, grid_size)
                    : Canvas.gen_new_board(grid_size, grid_size);
                // console.log("done creating board...");
                buffer = new Uint8ClampedArray(
                    memory.buffer,
                    canvas.get_pix_buf(),
                    canvas.canvas_width() * canvas.canvas_height() * 4,
                );
                image = new ImageData(
                    buffer,
                    canvas.canvas_width(),
                    canvas.canvas_height(),
                );
                canvas.render();
            });

            const renderLoop = () => {
                canvas.render();
                if (image.data.length == 0) {
                    // data sometimes gets invalidated when backing vector gets reallocated
                    // if this happens, just make a new buffer

                    buffer = new Uint8ClampedArray(
                        memory.buffer,
                        canvas.get_pix_buf(),
                        canvas.canvas_width() * canvas.canvas_height() * 4,
                    );
                    image = new ImageData(
                        buffer,
                        canvas.canvas_width(),
                        canvas.canvas_height(),
                    );
                }

                ctx.putImageData(image, 0, 0);

                if (canvas.game_won()) {
                    document.getElementById("win").textContent = "You won!";
                } else {
                    document.getElementById("win").textContent = "";
                }
                requestAnimationFrame(renderLoop);
            };

            requestAnimationFrame(renderLoop);
        </script>
    </body>
</html>
